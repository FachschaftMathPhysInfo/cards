package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"bytes"
	"context"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/FachschaftMathPhysInfo/cards/server/models"
	"github.com/FachschaftMathPhysInfo/cards/server/utils"
	anki "github.com/dheidemann/anki-go"
	"github.com/uptrace/bun"
)

// CreateDeck is the resolver for the createDeck field.
func (r *mutationResolver) CreateDeck(ctx context.Context, meta models.Deck, file graphql.Upload) (string, error) {
	// hash and copy to the buffer at the same time
	buf := &bytes.Buffer{}
	tee := io.TeeReader(file.File, buf)

	// generate the hash of the input file
	fileHash := sha256.New()
	if _, err := io.Copy(fileHash, tee); err != nil {
		log.Fatal(err)
	}
	encodedHash := hex.EncodeToString(fileHash.Sum(nil))
	meta.Hash = encodedHash

	// compress input file
	// this also checks for the correct file type as the init
	// of the apkg obj will fail if incorrect
	apkg, err := anki.ReadBytes(buf.Bytes())
	if err != nil {
		return "", err
	}
	defer apkg.Close()

	compressedApkg, err := apkg.CompressImages(50)
	if err != nil {
		log.Printf("unable to compress deck file: %s", err)
	} else {
		buf = bytes.NewBuffer(compressedApkg)
	}

	ext := filepath.Ext(file.Filename)
	meta.Filetype = ext

	// insert deck
	if _, err := r.DB.NewInsert().
		Model(&meta).
		Exec(ctx); err != nil {
		return "", err
	}

	// write file to storage
	deckfilesPath := "./deckfiles/"
	deckFilename := encodedHash + ext
	destFile, err := os.Create(deckfilesPath + deckFilename)
	if err != nil {
		return "", err
	}
	defer destFile.Close()

	_, err = io.Copy(destFile, buf)
	if err != nil {
		return "", err
	}

	err = destFile.Sync()
	if err != nil {
		return "", err
	}

	subject := "Neuer Stapel eingereicht!"
	body := fmt.Sprintf("Ein neuer Stapel wurde eingereicht:\n%s bei %s aus dem %s %s.\nBitte zeitnah autoristieren! <3\n%s/login",
		meta.Module, meta.Examiners, meta.Semester, strconv.Itoa(meta.Year), os.Getenv("API_URL"))
	err = utils.SendEmail(subject, body)
	if err != nil {
		log.Printf("email error: %s", err)
	}

	return encodedHash, nil
}

// UpdateDeck is the resolver for the updateDeck field.
func (r *mutationResolver) UpdateDeck(ctx context.Context, hash string, meta models.Deck) (string, error) {
	if _, err := r.DB.NewUpdate().
		Model(&meta).
		OmitZero().
		WherePK().
		Exec(ctx); err != nil {
		return "", err
	}

	return hash, nil
}

// DeleteDeck is the resolver for the deleteDeck field.
func (r *mutationResolver) DeleteDeck(ctx context.Context, hash string) (string, error) {
	if _, err := r.DB.NewDelete().
		Model((*models.Deck)(nil)).
		Where("hash = ?", hash).
		Exec(ctx); err != nil {
		return "", err
	}

	// remove deck from storage
	deckfilesPath := "./deckfiles/"
	deckfiles, err := filepath.Glob(deckfilesPath + hash + ".*")
	if err != nil {
		return "", err
	}

	err = os.Remove(deckfiles[0])
	if err != nil {
		return "", err
	}

	return hash, nil
}

// SetValid is the resolver for the setValid field.
func (r *mutationResolver) SetValid(ctx context.Context, hash string) (string, error) {
	if _, err := r.DB.NewUpdate().
		Model((*models.Deck)(nil)).
		Where("hash = ?", hash).
		Set("is_valid = true").
		Exec(ctx); err != nil {
		return "", err
	}

	return hash, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context, token string) (string, error) {
	if _, err := r.DB.NewDelete().
		Model((*models.Session)(nil)).
		Where("token = ?", token).
		Exec(ctx); err != nil {
		fmt.Print(err)
		return "", fmt.Errorf("Internal Server Error")
	}

	return token, nil
}

// Decks is the resolver for the decks field.
func (r *queryResolver) Decks(ctx context.Context, search *string, language []string, semester *string, year *int) ([]*models.Deck, error) {
	var decks []*models.Deck
	query := r.DB.NewSelect().
		Model(&decks)

	if search != nil && *search != "" {
		query = query.
			Where("examiners LIKE ?", "%"+*search+"%").
			WhereOr("module LIKE ?", "%"+*search+"%").
			WhereOr("subject LIKE ?", "%"+*search+"%").
			WhereOr("module_alt LIKE ?", "%"+*search+"%")
	}

	if semester != nil {
		query = query.
			Where("semester = ?", semester)
	}

	if year != nil {
		query = query.
			Where("year = ?", year)
	}

	if language != nil {
		query = query.
			Where("language IN (?)", bun.In(language))
	}

	if err := query.
		Scan(ctx); err != nil {
		return nil, err
	}

	return decks, nil
}

// IsActiveSession is the resolver for the isActiveSession field.
func (r *queryResolver) IsActiveSession(ctx context.Context, token string) (bool, error) {
	session := new(models.Session)
	if err := r.DB.NewSelect().
		Model(session).
		Where("token = ?", token).
		Scan(ctx); err != nil {
		fmt.Print(err)
		return false, fmt.Errorf("Internal Server Error")
	}

	if session == nil {
		return false, fmt.Errorf("No active session found")
	}

	if session.ExpiresAt.Before(time.Now()) {
		r.Mutation().Logout(ctx, token)
		return false, fmt.Errorf("Session is expired")
	}

	return true, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
