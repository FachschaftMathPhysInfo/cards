package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"bytes"
	"context"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"strconv"

	"github.com/99designs/gqlgen/graphql"
	"github.com/FachschaftMathPhysInfo/cards/server/models"
	"github.com/FachschaftMathPhysInfo/cards/server/utils"
	anki "github.com/dheidemann/anki-go"
)

// CreateDeck is the resolver for the createDeck field.
func (r *mutationResolver) CreateDeck(ctx context.Context, meta models.Deck, file graphql.Upload) (string, error) {
	// hash and copy to the buffer at the same time
	buf := &bytes.Buffer{}
	tee := io.TeeReader(file.File, buf)

	// generate the hash of the input file
	fileHash := sha256.New()
	if _, err := io.Copy(fileHash, tee); err != nil {
		log.Fatal(err)
	}
	encodedHash := hex.EncodeToString(fileHash.Sum(nil))
	meta.Hash = encodedHash

	// compress input file
	// this also checks for the correct file type as the init
	// of the apkg obj will fail if incorrect
	apkg, err := anki.ReadBytes(buf.Bytes())
	if err != nil {
		return "", err
	}
	defer apkg.Close()

	compressedApkg, err := apkg.CompressImages(50)
	if err != nil {
		log.Printf("unable to compress deck file: %s", err)
	} else {
		buf = bytes.NewBuffer(compressedApkg)
	}

	ext := filepath.Ext(file.Filename)
	meta.Filetype = ext

	// insert deck
	if _, err := r.DB.NewInsert().
		Model(&meta).
		Exec(ctx); err != nil {
		return "", err
	}

	// write file to storage
	deckfilesPath := "./deckfiles/"
	deckFilename := encodedHash + ext
	destFile, err := os.Create(deckfilesPath + deckFilename)
	if err != nil {
		return "", err
	}
	defer destFile.Close()

	_, err = io.Copy(destFile, buf)
	if err != nil {
		return "", err
	}

	err = destFile.Sync()
	if err != nil {
		return "", err
	}

	subject := "Neuer Stapel eingereicht!"
	body := fmt.Sprintf("Ein neuer Stapel wurde eingereicht:\n%s bei %s aus dem %s %s.\nBitte zeitnah autoristieren! <3\n%s/login",
		meta.Module, meta.Examiners, meta.Semester, strconv.Itoa(meta.Year), os.Getenv("API_URL"))
	err = utils.SendEmail(subject, body)
	if err != nil {
		log.Printf("email error: %s", err)
	}

	return encodedHash, nil
}

// UpdateDeck is the resolver for the updateDeck field.
func (r *mutationResolver) UpdateDeck(ctx context.Context, hash string, meta models.Deck) (string, error) {
	if _, err := r.DB.NewUpdate().
		Model(&meta).
		OmitZero().
		WherePK().
		Exec(ctx); err != nil {
		return "", err
	}

	return hash, nil
}

// DeleteDeck is the resolver for the deleteDeck field.
func (r *mutationResolver) DeleteDeck(ctx context.Context, hash string) (string, error) {
	if _, err := r.DB.NewDelete().
		Model((*models.Deck)(nil)).
		Where("hash = ?", hash).
		Exec(ctx); err != nil {
		return "", err
	}

	// remove deck from storage
	deckfilesPath := "./deckfiles/"
	deckfiles, err := filepath.Glob(deckfilesPath + hash + ".*")
	if err != nil {
		return "", err
	}

	err = os.Remove(deckfiles[0])
	if err != nil {
		return "", err
	}

	return hash, nil
}

// SetValid is the resolver for the setValid field.
func (r *mutationResolver) SetValid(ctx context.Context, hash string) (string, error) {
	if _, err := r.DB.NewUpdate().
		Model((*models.Deck)(nil)).
		Where("hash = ?", hash).
		Set("is_valid = true").
		Exec(ctx); err != nil {
		return "", err
	}

	return hash, nil
}

// Decks is the resolver for the decks field.
func (r *queryResolver) Decks(ctx context.Context) ([]*models.Deck, error) {
	var decks []*models.Deck
	if err := r.DB.NewSelect().
		Model(&decks).
		Scan(ctx); err != nil {
		return nil, err
	}

	return decks, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
