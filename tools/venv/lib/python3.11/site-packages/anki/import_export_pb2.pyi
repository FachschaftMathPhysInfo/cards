"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
Copyright: Ankitects Pty Ltd and contributors
License: GNU AGPL, version 3 or later; http://www.gnu.org/licenses/agpl.html
"""
import anki.cards_pb2
import anki.collection_pb2
import anki.generic_pb2
import anki.notes_pb2
import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _ImportAnkiPackageUpdateCondition:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _ImportAnkiPackageUpdateConditionEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ImportAnkiPackageUpdateCondition.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    IMPORT_ANKI_PACKAGE_UPDATE_CONDITION_IF_NEWER: _ImportAnkiPackageUpdateCondition.ValueType  # 0
    IMPORT_ANKI_PACKAGE_UPDATE_CONDITION_ALWAYS: _ImportAnkiPackageUpdateCondition.ValueType  # 1
    IMPORT_ANKI_PACKAGE_UPDATE_CONDITION_NEVER: _ImportAnkiPackageUpdateCondition.ValueType  # 2

class ImportAnkiPackageUpdateCondition(_ImportAnkiPackageUpdateCondition, metaclass=_ImportAnkiPackageUpdateConditionEnumTypeWrapper): ...

IMPORT_ANKI_PACKAGE_UPDATE_CONDITION_IF_NEWER: ImportAnkiPackageUpdateCondition.ValueType  # 0
IMPORT_ANKI_PACKAGE_UPDATE_CONDITION_ALWAYS: ImportAnkiPackageUpdateCondition.ValueType  # 1
IMPORT_ANKI_PACKAGE_UPDATE_CONDITION_NEVER: ImportAnkiPackageUpdateCondition.ValueType  # 2
global___ImportAnkiPackageUpdateCondition = ImportAnkiPackageUpdateCondition

@typing_extensions.final
class ImportCollectionPackageRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    COL_PATH_FIELD_NUMBER: builtins.int
    BACKUP_PATH_FIELD_NUMBER: builtins.int
    MEDIA_FOLDER_FIELD_NUMBER: builtins.int
    MEDIA_DB_FIELD_NUMBER: builtins.int
    col_path: builtins.str
    backup_path: builtins.str
    media_folder: builtins.str
    media_db: builtins.str
    def __init__(
        self,
        *,
        col_path: builtins.str = ...,
        backup_path: builtins.str = ...,
        media_folder: builtins.str = ...,
        media_db: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["backup_path", b"backup_path", "col_path", b"col_path", "media_db", b"media_db", "media_folder", b"media_folder"]) -> None: ...

global___ImportCollectionPackageRequest = ImportCollectionPackageRequest

@typing_extensions.final
class ExportCollectionPackageRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    OUT_PATH_FIELD_NUMBER: builtins.int
    INCLUDE_MEDIA_FIELD_NUMBER: builtins.int
    LEGACY_FIELD_NUMBER: builtins.int
    out_path: builtins.str
    include_media: builtins.bool
    legacy: builtins.bool
    def __init__(
        self,
        *,
        out_path: builtins.str = ...,
        include_media: builtins.bool = ...,
        legacy: builtins.bool = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["include_media", b"include_media", "legacy", b"legacy", "out_path", b"out_path"]) -> None: ...

global___ExportCollectionPackageRequest = ExportCollectionPackageRequest

@typing_extensions.final
class ImportAnkiPackageOptions(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MERGE_NOTETYPES_FIELD_NUMBER: builtins.int
    UPDATE_NOTES_FIELD_NUMBER: builtins.int
    UPDATE_NOTETYPES_FIELD_NUMBER: builtins.int
    WITH_SCHEDULING_FIELD_NUMBER: builtins.int
    WITH_DECK_CONFIGS_FIELD_NUMBER: builtins.int
    merge_notetypes: builtins.bool
    update_notes: global___ImportAnkiPackageUpdateCondition.ValueType
    update_notetypes: global___ImportAnkiPackageUpdateCondition.ValueType
    with_scheduling: builtins.bool
    with_deck_configs: builtins.bool
    def __init__(
        self,
        *,
        merge_notetypes: builtins.bool = ...,
        update_notes: global___ImportAnkiPackageUpdateCondition.ValueType = ...,
        update_notetypes: global___ImportAnkiPackageUpdateCondition.ValueType = ...,
        with_scheduling: builtins.bool = ...,
        with_deck_configs: builtins.bool = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["merge_notetypes", b"merge_notetypes", "update_notes", b"update_notes", "update_notetypes", b"update_notetypes", "with_deck_configs", b"with_deck_configs", "with_scheduling", b"with_scheduling"]) -> None: ...

global___ImportAnkiPackageOptions = ImportAnkiPackageOptions

@typing_extensions.final
class ImportAnkiPackageRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PACKAGE_PATH_FIELD_NUMBER: builtins.int
    OPTIONS_FIELD_NUMBER: builtins.int
    package_path: builtins.str
    @property
    def options(self) -> global___ImportAnkiPackageOptions: ...
    def __init__(
        self,
        *,
        package_path: builtins.str = ...,
        options: global___ImportAnkiPackageOptions | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["options", b"options"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["options", b"options", "package_path", b"package_path"]) -> None: ...

global___ImportAnkiPackageRequest = ImportAnkiPackageRequest

@typing_extensions.final
class ImportResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing_extensions.final
    class Note(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        ID_FIELD_NUMBER: builtins.int
        FIELDS_FIELD_NUMBER: builtins.int
        @property
        def id(self) -> anki.notes_pb2.NoteId: ...
        @property
        def fields(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]: ...
        def __init__(
            self,
            *,
            id: anki.notes_pb2.NoteId | None = ...,
            fields: collections.abc.Iterable[builtins.str] | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["id", b"id"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["fields", b"fields", "id", b"id"]) -> None: ...

    @typing_extensions.final
    class Log(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        NEW_FIELD_NUMBER: builtins.int
        UPDATED_FIELD_NUMBER: builtins.int
        DUPLICATE_FIELD_NUMBER: builtins.int
        CONFLICTING_FIELD_NUMBER: builtins.int
        FIRST_FIELD_MATCH_FIELD_NUMBER: builtins.int
        MISSING_NOTETYPE_FIELD_NUMBER: builtins.int
        MISSING_DECK_FIELD_NUMBER: builtins.int
        EMPTY_FIRST_FIELD_FIELD_NUMBER: builtins.int
        DUPE_RESOLUTION_FIELD_NUMBER: builtins.int
        FOUND_NOTES_FIELD_NUMBER: builtins.int
        @property
        def new(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ImportResponse.Note]: ...
        @property
        def updated(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ImportResponse.Note]: ...
        @property
        def duplicate(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ImportResponse.Note]: ...
        @property
        def conflicting(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ImportResponse.Note]: ...
        @property
        def first_field_match(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ImportResponse.Note]: ...
        @property
        def missing_notetype(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ImportResponse.Note]: ...
        @property
        def missing_deck(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ImportResponse.Note]: ...
        @property
        def empty_first_field(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ImportResponse.Note]: ...
        dupe_resolution: global___CsvMetadata.DupeResolution.ValueType
        found_notes: builtins.int
        def __init__(
            self,
            *,
            new: collections.abc.Iterable[global___ImportResponse.Note] | None = ...,
            updated: collections.abc.Iterable[global___ImportResponse.Note] | None = ...,
            duplicate: collections.abc.Iterable[global___ImportResponse.Note] | None = ...,
            conflicting: collections.abc.Iterable[global___ImportResponse.Note] | None = ...,
            first_field_match: collections.abc.Iterable[global___ImportResponse.Note] | None = ...,
            missing_notetype: collections.abc.Iterable[global___ImportResponse.Note] | None = ...,
            missing_deck: collections.abc.Iterable[global___ImportResponse.Note] | None = ...,
            empty_first_field: collections.abc.Iterable[global___ImportResponse.Note] | None = ...,
            dupe_resolution: global___CsvMetadata.DupeResolution.ValueType = ...,
            found_notes: builtins.int = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["conflicting", b"conflicting", "dupe_resolution", b"dupe_resolution", "duplicate", b"duplicate", "empty_first_field", b"empty_first_field", "first_field_match", b"first_field_match", "found_notes", b"found_notes", "missing_deck", b"missing_deck", "missing_notetype", b"missing_notetype", "new", b"new", "updated", b"updated"]) -> None: ...

    CHANGES_FIELD_NUMBER: builtins.int
    LOG_FIELD_NUMBER: builtins.int
    @property
    def changes(self) -> anki.collection_pb2.OpChanges: ...
    @property
    def log(self) -> global___ImportResponse.Log: ...
    def __init__(
        self,
        *,
        changes: anki.collection_pb2.OpChanges | None = ...,
        log: global___ImportResponse.Log | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["changes", b"changes", "log", b"log"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["changes", b"changes", "log", b"log"]) -> None: ...

global___ImportResponse = ImportResponse

@typing_extensions.final
class ExportAnkiPackageRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    OUT_PATH_FIELD_NUMBER: builtins.int
    OPTIONS_FIELD_NUMBER: builtins.int
    LIMIT_FIELD_NUMBER: builtins.int
    out_path: builtins.str
    @property
    def options(self) -> global___ExportAnkiPackageOptions: ...
    @property
    def limit(self) -> global___ExportLimit: ...
    def __init__(
        self,
        *,
        out_path: builtins.str = ...,
        options: global___ExportAnkiPackageOptions | None = ...,
        limit: global___ExportLimit | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["limit", b"limit", "options", b"options"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["limit", b"limit", "options", b"options", "out_path", b"out_path"]) -> None: ...

global___ExportAnkiPackageRequest = ExportAnkiPackageRequest

@typing_extensions.final
class ExportAnkiPackageOptions(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    WITH_SCHEDULING_FIELD_NUMBER: builtins.int
    WITH_DECK_CONFIGS_FIELD_NUMBER: builtins.int
    WITH_MEDIA_FIELD_NUMBER: builtins.int
    LEGACY_FIELD_NUMBER: builtins.int
    with_scheduling: builtins.bool
    with_deck_configs: builtins.bool
    with_media: builtins.bool
    legacy: builtins.bool
    def __init__(
        self,
        *,
        with_scheduling: builtins.bool = ...,
        with_deck_configs: builtins.bool = ...,
        with_media: builtins.bool = ...,
        legacy: builtins.bool = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["legacy", b"legacy", "with_deck_configs", b"with_deck_configs", "with_media", b"with_media", "with_scheduling", b"with_scheduling"]) -> None: ...

global___ExportAnkiPackageOptions = ExportAnkiPackageOptions

@typing_extensions.final
class PackageMetadata(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _Version:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _VersionEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[PackageMetadata._Version.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        VERSION_UNKNOWN: PackageMetadata._Version.ValueType  # 0
        VERSION_LEGACY_1: PackageMetadata._Version.ValueType  # 1
        """When `meta` missing, and collection.anki2 file present."""
        VERSION_LEGACY_2: PackageMetadata._Version.ValueType  # 2
        """When `meta` missing, and collection.anki21 file present."""
        VERSION_LATEST: PackageMetadata._Version.ValueType  # 3
        """Implies MediaEntry media map, and zstd compression.
        collection.21b file
        """

    class Version(_Version, metaclass=_VersionEnumTypeWrapper): ...
    VERSION_UNKNOWN: PackageMetadata.Version.ValueType  # 0
    VERSION_LEGACY_1: PackageMetadata.Version.ValueType  # 1
    """When `meta` missing, and collection.anki2 file present."""
    VERSION_LEGACY_2: PackageMetadata.Version.ValueType  # 2
    """When `meta` missing, and collection.anki21 file present."""
    VERSION_LATEST: PackageMetadata.Version.ValueType  # 3
    """Implies MediaEntry media map, and zstd compression.
    collection.21b file
    """

    VERSION_FIELD_NUMBER: builtins.int
    version: global___PackageMetadata.Version.ValueType
    def __init__(
        self,
        *,
        version: global___PackageMetadata.Version.ValueType = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["version", b"version"]) -> None: ...

global___PackageMetadata = PackageMetadata

@typing_extensions.final
class MediaEntries(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing_extensions.final
    class MediaEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        NAME_FIELD_NUMBER: builtins.int
        SIZE_FIELD_NUMBER: builtins.int
        SHA1_FIELD_NUMBER: builtins.int
        LEGACY_ZIP_FILENAME_FIELD_NUMBER: builtins.int
        name: builtins.str
        size: builtins.int
        sha1: builtins.bytes
        legacy_zip_filename: builtins.int
        """/ Legacy media maps may include gaps in the media list, so the original
        / file index is recorded when importing from a HashMap. This field is not
        / set when exporting.
        """
        def __init__(
            self,
            *,
            name: builtins.str = ...,
            size: builtins.int = ...,
            sha1: builtins.bytes = ...,
            legacy_zip_filename: builtins.int | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["_legacy_zip_filename", b"_legacy_zip_filename", "legacy_zip_filename", b"legacy_zip_filename"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["_legacy_zip_filename", b"_legacy_zip_filename", "legacy_zip_filename", b"legacy_zip_filename", "name", b"name", "sha1", b"sha1", "size", b"size"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal["_legacy_zip_filename", b"_legacy_zip_filename"]) -> typing_extensions.Literal["legacy_zip_filename"] | None: ...

    ENTRIES_FIELD_NUMBER: builtins.int
    @property
    def entries(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___MediaEntries.MediaEntry]: ...
    def __init__(
        self,
        *,
        entries: collections.abc.Iterable[global___MediaEntries.MediaEntry] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["entries", b"entries"]) -> None: ...

global___MediaEntries = MediaEntries

@typing_extensions.final
class ImportCsvRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PATH_FIELD_NUMBER: builtins.int
    METADATA_FIELD_NUMBER: builtins.int
    path: builtins.str
    @property
    def metadata(self) -> global___CsvMetadata: ...
    def __init__(
        self,
        *,
        path: builtins.str = ...,
        metadata: global___CsvMetadata | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["metadata", b"metadata"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["metadata", b"metadata", "path", b"path"]) -> None: ...

global___ImportCsvRequest = ImportCsvRequest

@typing_extensions.final
class CsvMetadataRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PATH_FIELD_NUMBER: builtins.int
    DELIMITER_FIELD_NUMBER: builtins.int
    NOTETYPE_ID_FIELD_NUMBER: builtins.int
    DECK_ID_FIELD_NUMBER: builtins.int
    IS_HTML_FIELD_NUMBER: builtins.int
    path: builtins.str
    delimiter: global___CsvMetadata.Delimiter.ValueType
    notetype_id: builtins.int
    deck_id: builtins.int
    is_html: builtins.bool
    def __init__(
        self,
        *,
        path: builtins.str = ...,
        delimiter: global___CsvMetadata.Delimiter.ValueType | None = ...,
        notetype_id: builtins.int | None = ...,
        deck_id: builtins.int | None = ...,
        is_html: builtins.bool | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["_deck_id", b"_deck_id", "_delimiter", b"_delimiter", "_is_html", b"_is_html", "_notetype_id", b"_notetype_id", "deck_id", b"deck_id", "delimiter", b"delimiter", "is_html", b"is_html", "notetype_id", b"notetype_id"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["_deck_id", b"_deck_id", "_delimiter", b"_delimiter", "_is_html", b"_is_html", "_notetype_id", b"_notetype_id", "deck_id", b"deck_id", "delimiter", b"delimiter", "is_html", b"is_html", "notetype_id", b"notetype_id", "path", b"path"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_deck_id", b"_deck_id"]) -> typing_extensions.Literal["deck_id"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_delimiter", b"_delimiter"]) -> typing_extensions.Literal["delimiter"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_is_html", b"_is_html"]) -> typing_extensions.Literal["is_html"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_notetype_id", b"_notetype_id"]) -> typing_extensions.Literal["notetype_id"] | None: ...

global___CsvMetadataRequest = CsvMetadataRequest

@typing_extensions.final
class CsvMetadata(google.protobuf.message.Message):
    """Column indices are 1-based to make working with them in TS easier, where
    unset numerical fields default to 0.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _DupeResolution:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _DupeResolutionEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[CsvMetadata._DupeResolution.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        UPDATE: CsvMetadata._DupeResolution.ValueType  # 0
        PRESERVE: CsvMetadata._DupeResolution.ValueType  # 1
        DUPLICATE: CsvMetadata._DupeResolution.ValueType  # 2
        """UPDATE_IF_NEWER = 3;"""

    class DupeResolution(_DupeResolution, metaclass=_DupeResolutionEnumTypeWrapper): ...
    UPDATE: CsvMetadata.DupeResolution.ValueType  # 0
    PRESERVE: CsvMetadata.DupeResolution.ValueType  # 1
    DUPLICATE: CsvMetadata.DupeResolution.ValueType  # 2
    """UPDATE_IF_NEWER = 3;"""

    class _Delimiter:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _DelimiterEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[CsvMetadata._Delimiter.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        TAB: CsvMetadata._Delimiter.ValueType  # 0
        PIPE: CsvMetadata._Delimiter.ValueType  # 1
        SEMICOLON: CsvMetadata._Delimiter.ValueType  # 2
        COLON: CsvMetadata._Delimiter.ValueType  # 3
        COMMA: CsvMetadata._Delimiter.ValueType  # 4
        SPACE: CsvMetadata._Delimiter.ValueType  # 5

    class Delimiter(_Delimiter, metaclass=_DelimiterEnumTypeWrapper):
        """Order roughly in ascending expected frequency in note text, because the
        delimiter detection algorithm is stupidly picking the first one it
        encounters.
        """

    TAB: CsvMetadata.Delimiter.ValueType  # 0
    PIPE: CsvMetadata.Delimiter.ValueType  # 1
    SEMICOLON: CsvMetadata.Delimiter.ValueType  # 2
    COLON: CsvMetadata.Delimiter.ValueType  # 3
    COMMA: CsvMetadata.Delimiter.ValueType  # 4
    SPACE: CsvMetadata.Delimiter.ValueType  # 5

    class _MatchScope:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _MatchScopeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[CsvMetadata._MatchScope.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        NOTETYPE: CsvMetadata._MatchScope.ValueType  # 0
        NOTETYPE_AND_DECK: CsvMetadata._MatchScope.ValueType  # 1

    class MatchScope(_MatchScope, metaclass=_MatchScopeEnumTypeWrapper): ...
    NOTETYPE: CsvMetadata.MatchScope.ValueType  # 0
    NOTETYPE_AND_DECK: CsvMetadata.MatchScope.ValueType  # 1

    @typing_extensions.final
    class MappedNotetype(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        ID_FIELD_NUMBER: builtins.int
        FIELD_COLUMNS_FIELD_NUMBER: builtins.int
        id: builtins.int
        @property
        def field_columns(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
            """Source column indices for note fields. One-based. 0 means n/a."""
        def __init__(
            self,
            *,
            id: builtins.int = ...,
            field_columns: collections.abc.Iterable[builtins.int] | None = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["field_columns", b"field_columns", "id", b"id"]) -> None: ...

    DELIMITER_FIELD_NUMBER: builtins.int
    IS_HTML_FIELD_NUMBER: builtins.int
    GLOBAL_TAGS_FIELD_NUMBER: builtins.int
    UPDATED_TAGS_FIELD_NUMBER: builtins.int
    COLUMN_LABELS_FIELD_NUMBER: builtins.int
    DECK_ID_FIELD_NUMBER: builtins.int
    DECK_COLUMN_FIELD_NUMBER: builtins.int
    GLOBAL_NOTETYPE_FIELD_NUMBER: builtins.int
    NOTETYPE_COLUMN_FIELD_NUMBER: builtins.int
    TAGS_COLUMN_FIELD_NUMBER: builtins.int
    FORCE_DELIMITER_FIELD_NUMBER: builtins.int
    FORCE_IS_HTML_FIELD_NUMBER: builtins.int
    PREVIEW_FIELD_NUMBER: builtins.int
    GUID_COLUMN_FIELD_NUMBER: builtins.int
    DUPE_RESOLUTION_FIELD_NUMBER: builtins.int
    MATCH_SCOPE_FIELD_NUMBER: builtins.int
    delimiter: global___CsvMetadata.Delimiter.ValueType
    is_html: builtins.bool
    @property
    def global_tags(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]: ...
    @property
    def updated_tags(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]: ...
    @property
    def column_labels(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """Column names as defined by the file or empty strings otherwise. Also used
        to determine the number of columns.
        """
    deck_id: builtins.int
    deck_column: builtins.int
    """One-based. 0 means n/a."""
    @property
    def global_notetype(self) -> global___CsvMetadata.MappedNotetype:
        """One notetype for all rows with given column mapping."""
    notetype_column: builtins.int
    """Row-specific notetypes with automatic mapping by index.
    One-based. 0 means n/a.
    """
    tags_column: builtins.int
    """One-based. 0 means n/a."""
    force_delimiter: builtins.bool
    force_is_html: builtins.bool
    @property
    def preview(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[anki.generic_pb2.StringList]: ...
    guid_column: builtins.int
    dupe_resolution: global___CsvMetadata.DupeResolution.ValueType
    match_scope: global___CsvMetadata.MatchScope.ValueType
    def __init__(
        self,
        *,
        delimiter: global___CsvMetadata.Delimiter.ValueType = ...,
        is_html: builtins.bool = ...,
        global_tags: collections.abc.Iterable[builtins.str] | None = ...,
        updated_tags: collections.abc.Iterable[builtins.str] | None = ...,
        column_labels: collections.abc.Iterable[builtins.str] | None = ...,
        deck_id: builtins.int = ...,
        deck_column: builtins.int = ...,
        global_notetype: global___CsvMetadata.MappedNotetype | None = ...,
        notetype_column: builtins.int = ...,
        tags_column: builtins.int = ...,
        force_delimiter: builtins.bool = ...,
        force_is_html: builtins.bool = ...,
        preview: collections.abc.Iterable[anki.generic_pb2.StringList] | None = ...,
        guid_column: builtins.int = ...,
        dupe_resolution: global___CsvMetadata.DupeResolution.ValueType = ...,
        match_scope: global___CsvMetadata.MatchScope.ValueType = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["deck", b"deck", "deck_column", b"deck_column", "deck_id", b"deck_id", "global_notetype", b"global_notetype", "notetype", b"notetype", "notetype_column", b"notetype_column"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["column_labels", b"column_labels", "deck", b"deck", "deck_column", b"deck_column", "deck_id", b"deck_id", "delimiter", b"delimiter", "dupe_resolution", b"dupe_resolution", "force_delimiter", b"force_delimiter", "force_is_html", b"force_is_html", "global_notetype", b"global_notetype", "global_tags", b"global_tags", "guid_column", b"guid_column", "is_html", b"is_html", "match_scope", b"match_scope", "notetype", b"notetype", "notetype_column", b"notetype_column", "preview", b"preview", "tags_column", b"tags_column", "updated_tags", b"updated_tags"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["deck", b"deck"]) -> typing_extensions.Literal["deck_id", "deck_column"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["notetype", b"notetype"]) -> typing_extensions.Literal["global_notetype", "notetype_column"] | None: ...

global___CsvMetadata = CsvMetadata

@typing_extensions.final
class ExportCardCsvRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    OUT_PATH_FIELD_NUMBER: builtins.int
    WITH_HTML_FIELD_NUMBER: builtins.int
    LIMIT_FIELD_NUMBER: builtins.int
    out_path: builtins.str
    with_html: builtins.bool
    @property
    def limit(self) -> global___ExportLimit: ...
    def __init__(
        self,
        *,
        out_path: builtins.str = ...,
        with_html: builtins.bool = ...,
        limit: global___ExportLimit | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["limit", b"limit"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["limit", b"limit", "out_path", b"out_path", "with_html", b"with_html"]) -> None: ...

global___ExportCardCsvRequest = ExportCardCsvRequest

@typing_extensions.final
class ExportNoteCsvRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    OUT_PATH_FIELD_NUMBER: builtins.int
    WITH_HTML_FIELD_NUMBER: builtins.int
    WITH_TAGS_FIELD_NUMBER: builtins.int
    WITH_DECK_FIELD_NUMBER: builtins.int
    WITH_NOTETYPE_FIELD_NUMBER: builtins.int
    WITH_GUID_FIELD_NUMBER: builtins.int
    LIMIT_FIELD_NUMBER: builtins.int
    out_path: builtins.str
    with_html: builtins.bool
    with_tags: builtins.bool
    with_deck: builtins.bool
    with_notetype: builtins.bool
    with_guid: builtins.bool
    @property
    def limit(self) -> global___ExportLimit: ...
    def __init__(
        self,
        *,
        out_path: builtins.str = ...,
        with_html: builtins.bool = ...,
        with_tags: builtins.bool = ...,
        with_deck: builtins.bool = ...,
        with_notetype: builtins.bool = ...,
        with_guid: builtins.bool = ...,
        limit: global___ExportLimit | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["limit", b"limit"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["limit", b"limit", "out_path", b"out_path", "with_deck", b"with_deck", "with_guid", b"with_guid", "with_html", b"with_html", "with_notetype", b"with_notetype", "with_tags", b"with_tags"]) -> None: ...

global___ExportNoteCsvRequest = ExportNoteCsvRequest

@typing_extensions.final
class ExportLimit(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    WHOLE_COLLECTION_FIELD_NUMBER: builtins.int
    DECK_ID_FIELD_NUMBER: builtins.int
    NOTE_IDS_FIELD_NUMBER: builtins.int
    CARD_IDS_FIELD_NUMBER: builtins.int
    @property
    def whole_collection(self) -> anki.generic_pb2.Empty: ...
    deck_id: builtins.int
    @property
    def note_ids(self) -> anki.notes_pb2.NoteIds: ...
    @property
    def card_ids(self) -> anki.cards_pb2.CardIds: ...
    def __init__(
        self,
        *,
        whole_collection: anki.generic_pb2.Empty | None = ...,
        deck_id: builtins.int = ...,
        note_ids: anki.notes_pb2.NoteIds | None = ...,
        card_ids: anki.cards_pb2.CardIds | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["card_ids", b"card_ids", "deck_id", b"deck_id", "limit", b"limit", "note_ids", b"note_ids", "whole_collection", b"whole_collection"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["card_ids", b"card_ids", "deck_id", b"deck_id", "limit", b"limit", "note_ids", b"note_ids", "whole_collection", b"whole_collection"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["limit", b"limit"]) -> typing_extensions.Literal["whole_collection", "deck_id", "note_ids", "card_ids"] | None: ...

global___ExportLimit = ExportLimit
